

pid_t wait(int *status);
参数：表示等待子进程状态
	表示正常退出：
	WIFEXITED(status) 如果这个宏为真，则表示正常退出
	WEXITSTATUS(status) 表示获取正常退出返回值，返回值范围0~255

	表示异常退出
	WIFSIGNALED(status) : 表示异常退出 则为真
	WTERMSIG(status) ： 表示返回信号值

求素数 3000 ～ 6000
练习：
	创建10个进程 

==============================
进程环境
	extern char **environ;
案例：
	HOSTNAME=localhost.localdomain

获取环境变量
	char *getenv(const char *name);
	参数：表示变量名

修改环境变量
	int setenv(const char *name, const char *value, int overwrite);
	第一个参数：表示变量名
	第二个参数：表示变量值
	第三个参数：表示是否修改
		1 ： 表示修改
		0 ： 表示不修改
	返回值：
		成功0
		失败-1

	注意：如果是一个不存在的环境变量，设置这个环境变量，则会不会设置成功
	
	int putenv(char *string);
		string => name=value

删除环境变量
	int unsetenv(const char *name);

清空所有的环境变量
	int clearenv(void);

==========================
exec家族函数 执行外部命令函数
	int execl(const char *path, const char *arg, ...);
	第一个参数：表示命令路径 必须是绝对路径
	第二个参数：表示执行命令
	...		  : 表示对命令补充
	返回值：
		失败：-1
	int execlp(const char *file, const char *arg, ...);
	第一个参数：表示文件路径 即可以是绝对路径，也可以是相对路径
	int execle(const char *path, const char *arg,
			..., char * const envp[]);
			
	第一个参数：表示命令路径 必须是绝对路径
	第二个参数：表示执行命令
	...		  : 表示对命令补充
	后面的参数：表示环境变量

	int execv(const char *path, char *const argv[]);
	第一个参数：表示命令路径
	第二个参数：表示命令和参数
	int execvp(const char *file, char *const argv[]);
	int execve(const char *filename, char *const argv[],
	                  char *const envp[]);

	第一个参数：命令路径 必须是绝对路径
	第二个参数：表示传递参数
	第三个参数：表示环境变量
＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
孤儿进程：
	父进程创建一个子进程， 而父进程退出而子进程还处于运行状态，则这个子进程就变成孤儿进程。
	孤儿进程就会被1号进程收养。

僵尸进程：
	父进程创建一个子进程，子进程退出而父进化一直处于运行状态

守护进程：
	一直运行在系统后台，用于监听用户输入指令，监听到这些指令作出相应的操作。
	1 创建孤儿进程
	2 
		受原控制终端影响
		受原进程组影响
			获取进程组id
			pid_t getpgrp(void);
			pid_t getpgid(pid_t pid);
		受原会话影响
			获取会话id
			pid_t getsid(pid_t pid);
		
		创建一个新的会话
		pid_t setsid(void);

	3 修改当前工作目录
	4 修改umask值
	5 关闭文件描述符
	6 接受信号处理

创建守护进化
	int daemon(int nochdir, int noclose);


获取资源限额
	int getrlimit(int resource, struct rlimit *rlim);
	第一个参数：表示资源
		RLIMIT_NOFILE ：表示获取文件描述符资源
		RLIMIT_STACK  ：表示堆栈大小
			12M => 4G => 3G
	第二个参数：表示资源结构体
	struct rlimit {
		表示软资源限额
		rlim_t rlim_cur;  /* Soft limit */
		表示硬资源限额
		rlim_t rlim_max;  /* Hard limit (ceiling for rlim_cur) */
	};
	返回值：
		成功0
		失败-1
设置资源限额	
	int setrlimit(int resource, const struct rlimit *rlim);

＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
创建进程
	pid_t vfork(void);

	1 确保子进程先运行，父进程后运行
	2 vfork创建进化空间共享
		fork创建进化空间是独享
	3 vfork()子进程不可以用return退出，会导致段错误	










